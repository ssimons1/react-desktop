'use strict';

exports.__esModule = true;
exports.parse = parse;
exports.create = create;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _lodashObjectHas = require('lodash/object/has');

var _lodashObjectHas2 = _interopRequireDefault(_lodashObjectHas);

var _lodashObjectPick = require('lodash/object/pick');

var _lodashObjectPick2 = _interopRequireDefault(_lodashObjectPick);

var _node = require('./node');

var _utils = require('./utils');

var _cssSelectorParser = require('css-selector-parser');

var _cache = require('./cache');

var _cache2 = _interopRequireDefault(_cache);

var _fnName = require('fn-name');

var _fnName2 = _interopRequireDefault(_fnName);

var _escapeRegexp = require('escape-regexp');

var _escapeRegexp2 = _interopRequireDefault(_escapeRegexp);

var returnsTrue = function returnsTrue() {
  return true;
};

var parseCache = _cache2['default']();
var parser = new _cssSelectorParser.CssSelectorParser();

var name = function name(type) {
  return typeof type === 'string' ? type : type.displayName || _fnName2['default'](type) || '';
};

function ignoreTextNodes(fn) {
  return function () {
    return arguments[0].nodeType === _node.NODE_TYPES.TEXT ? false : fn.apply(undefined, arguments);
  };
}

function parse(selector) {
  if (typeof selector !== 'string') return selector;

  var parsed = parseCache.get(selector);

  if (parsed) return parsed;
  var ast = parser.parse(selector);

  if (ast.rule) {
    var rule = ast.rule;
    parsed = { rules: getRule(rule), ast: ast };
  } else if (ast.selectors) {
    parsed = {
      ast: ast,
      rules: ast.selectors.map(function (s) {
        return getRule(s.rule);
      }),
      multiple: true
    };
  }

  return parseCache.set(selector, parsed);

  function getRule(rule) {
    if (!rule) return [];
    return getRule(rule.rule).concat(rule);
  }
}

function create() {
  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

  var NESTING = Object.create(null);
  var PSEUDOS = Object.create(null);

  var prefix = options.prefix || 'sub_____';
  var rValueSub = new RegExp(_escapeRegexp2['default'](prefix) + '\\d+', 'gm');

  return {
    compile: compile,
    compileRule: compileRule,

    selector: _utils.createSelector(prefix),

    registerNesting: function registerNesting(name, fn) {
      if (name !== 'any') parser.registerNestingOperators(name);
      NESTING[name] = fn;
    },

    registerPseudo: function registerPseudo(name, fn) {
      PSEUDOS[name] = fn;
    }
  };

  function compile(selector) {
    var values = arguments.length <= 1 || arguments[1] === undefined ? Object.create(null) : arguments[1];

    if (selector.selector) {
      values = selector.valueMap;
      selector = selector.selector;
    }

    var _parse = parse(selector);

    var rules = _parse.rules;
    var multiple = _parse.multiple;
    var compiled = undefined;

    if (!multiple) compiled = compileRule(rules, values);else {
      compiled = rules.map(function (ruleSet) {
        return compileRule(ruleSet, values);
      }).reduce(function (current, next) {
        return function () {
          return current.apply(undefined, arguments) || next.apply(undefined, arguments);
        };
      });
    }

    return compiled;
  }

  function compileRule(rules, values) {
    var fns = [];
    var rule = rules[0];

    if (rule.tagName) fns.push(getTagMatcher(rule, values));

    if (rule.attrs) fns.push(getPropMatcher(rule, values));

    if (rule.id) fns.push(getIdMatcher(rule, values));

    if (rule.classNames) fns.push(getClassNameMatcher(rule, values));

    if (rule.pseudos) {
      fns = fns.concat(rule.pseudos.map(function (pseudo) {
        return getPseudoMatcher(rule, values, pseudo);
      }));
    }

    if (_lodashObjectHas2['default'](rule, 'nestingOperator')) fns.push(getNestingMatcher(rule, values, rules));

    var compiledRule = fns.reduce(function (current) {
      var next = arguments.length <= 1 || arguments[1] === undefined ? returnsTrue : arguments[1];

      return function () {
        return current.apply(undefined, arguments) && next.apply(undefined, arguments);
      };
    });

    return function (element) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return compiledRule.apply(undefined, [_node.createNode(element)].concat(args));
    };
  }

  function getPseudoMatcher(rule, values, pseudo) {
    var createMatcher = PSEUDOS[pseudo.name],
        inner = pseudo.value || '',
        subValues = undefined;

    if (typeof createMatcher !== 'function') throw new Error('psuedo element: ' + pseudo.name + ' is not supported');

    if (subValues = inner.match(rValueSub)) inner = { selector: inner, valueMap: _lodashObjectPick2['default'](values, subValues) };

    return createMatcher(inner);
  }

  function getNestingMatcher(rule, values, rules) {
    var operator = rule.nestingOperator || 'any';
    var createMatcher = NESTING[operator];

    if (typeof createMatcher !== 'function') throw new Error('nesting operator: ' + operator + ' is not supported');

    return createMatcher(compileRule(rules.slice(1), values));
  }
}

function getIdMatcher(rule) {
  return ignoreTextNodes(function (_ref) {
    var props = _ref.element.props;

    if (!props || !_lodashObjectHas2['default'](props, 'id')) return false;
    return rule.id === '' + props.id;
  });
}

function getTagMatcher(rule, values) {
  var tagName = rule.tagName,
      test = undefined;

  if (_lodashObjectHas2['default'](values, rule.tagName)) tagName = values[rule.tagName];

  if (tagName === '*') test = returnsTrue;else {
    // interpolated value: `${MyList}.foo`
    // should be a function (todo?) strict compare.
    if (typeof tagName !== 'string') test = function (root) {
      return root.element.type === tagName;
    };else {
      // fallback to comparing string names
      test = function (root) {
        return name(root.element.type) === tagName;
      };
    }

    test = ignoreTextNodes(test);
  }

  return test;
}

function getClassNameMatcher(rule) {
  return ignoreTextNodes(function (_ref2) {
    var props = _ref2.element.props;

    if (!props || !_lodashObjectHas2['default'](props, 'className')) return false;

    var className = (' ' + props.className + ' ').replace(/[\t\r\n\f]/g, ' ');

    return rule.classNames.every(function (cls) {
      return className.indexOf(' ' + cls + ' ') >= 0;
    });
  });
}

function getPropMatcher(rule, values) {
  return ignoreTextNodes(function (_ref3) {
    var props = _ref3.element.props;
    return rule.attrs.every(function (attr) {
      // boolean prop: <input disabled />
      if (!_lodashObjectHas2['default'](attr, 'value')) return !!props[attr.name];

      // interpolated value: 'input[max=${5}]'
      // since we have the actual value vs serialized string
      // do a strict comparison
      if (_lodashObjectHas2['default'](values, attr.value)) return props[attr.name] === values[attr.value];

      // string value: 'input[max="5"]'
      // allow coearcion in the comparison
      return props[attr.name] == attr.value; // eslint-disable-line
    });
  });
}